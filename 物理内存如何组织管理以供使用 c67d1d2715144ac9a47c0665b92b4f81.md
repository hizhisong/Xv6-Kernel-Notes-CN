# 物理内存如何组织管理以供使用

Status: Completed
板块: 内存管理

<aside>
💡 对于内核虚拟地址空间的`0x80000000~PHYSTOP`这一段我们如何使用，通过怎样的数据结构管理？
下面就来回答这个问题

</aside>

# 使用什么数据结构管理 '页' ？

页 作为虚拟内存和物理内存管理的**最小单位**

> 我们给进程分配虚拟内存时是将内存大小切成一页一页大小一样的单元分配，映射到物理地址空间，我们建立映射时对于实际的物理内存条部分，我们也是采用一页一页的固定大小进行分配回收
> 

根据这样增加/删除动作时操作数据的性质，我们选择**链表/位图**进行管理

- 链表：将空闲页用链表串起来，对页的分配与回收对应链表节点的删除与增加
- 位图：为了记录位图数据结构，我们拿出一个Page存位图数据结构，**一位表示一页的使用情况**，1表示占用(已分配)，0表示空闲(未分配)

# 物理页*管理 -- kalloc.c

<aside>
💡 * [这里](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81.md)我们已经介绍过，用户进程想使用物理内存需要通过内核虚拟地址空间，内核虚拟地址空间映射至物理内存空间，内核通过分配内核虚拟地址空间给进程完成物理内存的分配

因此这里struct run链表串起来的**实际上**是**内核虚拟地址空间**中可供分配的页的地址们，可通过强转当成地址便于读写，当成整数便于计算

下述的“物理页”可以理解成 -- 直接映射到内核虚拟地址空间中`0x80000000~PHYSTOP`的物理内存

</aside>

## 数据结构

![                                   kalloc.c](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled.png)

                                   kalloc.c

我们可以看到，Xv6中使用链表的方式对物理页进行管理，`kmem` 作为对空闲物理页的封装

这里的struct run就是一个物理内存空闲页的起始物理地址，分配时会被强制转化成void*作为地址

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%201.png)

freelist、next都是一个指针，里面存着一个地址，这个地址指向下一个可用的物理页的起始地址，我们获取到了一个物理页的物理地址后就可以**沿着**这个物理地址一个页的大小(xv6默认4KB)去使用这个下面的空间

<aside>
💡 注意，这里我们使用到的地址都是虚拟地址，从分页机制开启之后，我们一直使用的就是虚拟地址。(只不过这部分的内核虚拟地址与物理地址直接映射)

</aside>

## 分配 一个物理页(4096-byte in xv6)

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%202.png)

## 回收 一个物理页

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%203.png)

## 连续回收

在内核启动时main.c/main()中调用kinit初始化内核内存空间

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%204.png)

这里我们看到我们在会回收指定的start、end物理地址间所有的物理页，注意这里对于起始地址会向上对齐，头插法一个个构造器空闲页节点

这样，我们就可以对外声明，**内核**虚拟地址空间end~PHYSTOP段为空闲页，可以向内核申请使用这段内存，同样用户进程也会通过这段申请内存使用

## Q: 多个进程会不会抢占到同一物理页？请找出防护机制代码

内存将分配器页集合抽象成 kmem，封装了物理页链表`struct run`和锁

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%205.png)

内核初始化时对物理页分配器页进行初始化

![Untitled](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81/Untitled%206.png)

后续内核、用户进程请求物理页时内核使用kalloc和kfree管理物理页的分配与回收，这两个函数里就会使用到kmem中的锁对同一物理页资源进行保护