# Lab: Multithreading -- 协程与同步barrier

板块: Lab

# Uthread: switching between threads

完成创建的用户线程的调度切换

- 设计：
    - 补全thread_create thread_schedule thread_switch
    - 调度器第一次执行thread_create创建的线程时，在线程自己的栈上执行传递给thread_create的函数指针
    - thread_switch 在切换出时保存线程寄存器 在切换回时恢复寄存器(modifying struct thread)
    - 在thread_schedule中调用thread_switch

# **多线程（用户态）**

## **Uthread**

本节分为三个部分：线程定义、调度算法、上下文切换

### **1. 线程的三个资源**

线程是轻量级的，一个线程控制块(struct thread)，一般包含独立的三个资源：

1. 状态 -- 简单定义三种{RUNNING RUNNABLE FREE}
2. 函数调用栈 -- {stack[STACK_SZ]}
3. 寄存器（上下文环境）-- {struct context}

### **2. 调度算法 -- 非抢占式 自愿放弃执行(协程)**

三个用户测试线程，每个线程执行一个函数，函数末尾每个线程执行一次调用调度函数(在一般的协程库中是resume函数)，放弃yield当前CPU，调度函数实现调度算法实现三个函数循环调用算法

<一般协程库提供yield函数与resume指定运行某个协程函数>

### **协程特点**

- 协程是在**串行**
- 由于串行所以**避免**考虑相互依赖代码的**data race问题** -- **省去同步**
- 协程间切换成本小 速度快 (**内核态线程间的切换引发trap，导致1. 上下文改变，2. 特权级改变 3.由于不信任内核代码对用户代码的额外检查**)
- **挂起/恢复**
    
    相比于**函数**，协程最大的特点就是支持 **挂起/恢复**。什么意思？我们来看下面这个场景就能明白。
    
    ![Untitled](Lab%20Multithreading%20--%20%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5barrier%2093561cd54789458a897ea1aad0309f6c/Untitled.png)
    
    上图中，控制流会在 `foo()` 和 `bar()` 之间进行切换。比如，在第 3 阶段时，控制流从 `foo()` 中再次转移到了 `bar()` 中，此时并不是简单的函数调用，而是从上一次离开 `bar()` 的位置 `std::cout << "1"` 之后继续执行。
    
    由此可见，协程与简单的函数调用之间的区别。实现协程的这种能力的关键，就是要实现 **挂起/恢复** 的能力。
    

### **协程适用场景 -- IO密集型任务**

CPU消耗很少，任务的大部分时间都在等待IO操作完成

### **实现原理**

这样在执行系统调用函数时，本来要陷入系统调用阻塞该线程，但我们这里可以适用库打桩机制，在程序运行时动态链接协程库，使得协程库中的相关函数替换协程的系统调用的调用。

### **3. 协程上下文切换**

和Xv6在调度时对进程间的上下文切换swtch struct context一样，将由被调用者需要保存调用者的寄存器保存到 user_context 中，待被调用者完成执行重新切换到该协程上来时，被调用者主动恢复原有协程的上下文和栈空间

本小节最终目的达成：测试整个用户态调度是否正确执行

![每一个协程所拥有的上下文(寄存器(指向某一协程的栈内存空间 && 其他寄存器))](Lab%20Multithreading%20--%20%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5barrier%2093561cd54789458a897ea1aad0309f6c/Untitled%201.png)

每一个协程所拥有的上下文(寄存器(指向某一协程的栈内存空间 && 其他寄存器))

![https://s2.loli.net/2022/03/12/pZCvok1XKudUmWs.png](https://s2.loli.net/2022/03/12/pZCvok1XKudUmWs.png)

### **4. 用户态抢占/协作线程意义？**

***内核作为一个Monitor是有统观全局的能力的*** ，周期性的时钟中断以及各类硬件中断使得内核可以获知一切内部和外部发生的情况，因此内核具备执行抢占的资格！

内核之所以有这个能力主要是由于现代处理器的中断设计：

**现代处理器 每执行完一条指令 都会 检测 一下是不是有外部或者内部的重要事件到来，如果有，便以【最高优先级】调度一段代码(中断处理程序)来处理，这段代码将打断一切正在执行的指令流！！所以这个机制叫做中断！**

因此在Linux中会在时钟中断来临时调用scheduler_tick()进行系统运行快照的检查(xv6也是这样做 在trap中)，

通过同步、异步信号：

- 在时钟中断处理程序中判断 ***当前进程指令流是不是执行太久了？其它等待进程是不是太饥饿了？*** -- 进行调度标记
- 利用随机到来的**任意硬件中断或者内部异常**，内核可以在中断处理程序中判断 ***是否需要一个相关的进程立即投入运行。***
比如磁盘读完毕中断意味着等待磁盘IO的进程需要立刻运行，网卡收包中断意味着网络服务进程需要更快被唤醒。

**在此看来：**

如果要实现用户态**抢占式**线程，只实现机制**不实现**机制产生的**效果**是**毫无意义**的，我们固然可以模拟内核抢占式调度的方法，利用**周期性信号**来纵览用户态进程全局实现用户态抢占，但想想完成一个计算密集型的用户线程抢占有什么意义呢？这并没有实现我们调度算法的最终目的 -- ***有效利用CPU！*** 所以最终一切以它为衡量标准。

因此，实现用户态的协作程序是有意义的。只有用户态线程自己知道什么时候它才要放弃CPU， ***用户态进程的多个线程之间是协作关系，而不是竞争关系！这个是在编程时决定的，而不是执行时决定的。***

例如I/O密集型任务对CPU占用率其实非常低，因此我们可以采用协程实现用户态的非抢占式任务调度。

[https://blog.csdn.net/dog250/article/details/89709706](https://blog.csdn.net/dog250/article/details/89709706)

## 线程同步barrier**()**

<aside>
💡 与__sync_synchronize()将其前后load、store指令不允许交换的编译器重排和CPU流水线指令重排的barrier不是一个东西

</aside>

![Untitled](Lab%20Multithreading%20--%20%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5barrier%2093561cd54789458a897ea1aad0309f6c/Untitled%202.png)

![https://s2.loli.net/2022/03/12/cQwr4evk8miofIZ.png](https://s2.loli.net/2022/03/12/cQwr4evk8miofIZ.png)

条件变量：负责同步

barriar锁：负责数据结构的并发保护

每个线程都启动了多轮循环，每轮循环都要使用一个barriar同步所有线程的停在某一轮循环，struct barriar的结构体中round负责检测，我们要实现的barriar就是**当所有线程都到达这个barriar后才能启动 “所有进程完成同一轮循环计数 round+1操作”**

---

有栈协程指每个协程会保存单独的上下文（执行栈、寄存器等），协程的唤醒和挂起就是拷贝、切换上下文；无栈协程指单个线程内所有协程都共享同一个执行栈，**协程的切换就是简单的函数返回**。

[有栈协程与无栈协程](Lab%20Multithreading%20--%20%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5barrier%2093561cd54789458a897ea1aad0309f6c/%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B%E4%B8%8E%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B%2021950671b558491694f04c44454392d5.md)

[CHAI'S BLOG](http://warmcat.org/chai/blog/?p=5558)

由于协程必须支持 **挂起/恢复**，因此对于挂起点的状态保存就显得极其关键。我们知道，线程在切换时，它的中断状态会保存在调用栈中。事实上，协程的中断状态也可以通过开辟相应的调用栈来保存。因此，**按照是否开辟相应的调用栈**，我们可以将协程分为两类：

- **有栈协程**（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈。
- **无栈协程**（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。

> 类似微信的 libco、阿里的 cooobjc、Golang 中的 goroutine、Lua 中的协程都是有栈协程；
类似 JavaScript、Dart 中的 await/async、Python 的 Generator、Kotlin 中的协程、C++20 中的 cooroutine 都是无栈协程。
> 

### **有栈协程**

有栈协程的一般实现是：在内存中给每个协程开辟一个栈内存，当协程挂起时会将它的运行时上下文（即栈空间）从系统栈中保存至其所分配的协程栈内存中，当协程恢复时会将其运行时上下文从协程栈内存中恢复至系统栈中。

![https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-stackful.png?x-oss-process=image/resize,w_800](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-stackful.png?x-oss-process=image/resize,w_800)

上图所示为在协程 `foo()` 和 `bar()` 之间切换时，栈空间的变化。很显然，**有栈协程会改变函数调用栈**。由于有栈协程需要保存各个协程自己的运行时上下文，一般会通过堆来分配内存空间。如果内存分配过小，可能会产生栈溢出；如果内存分配过大，可能会产生内存浪费。因此，很多编程语言对此进行了各种优化。

另一方面，当协程恢复时，**需要将运行时上下文从堆中拷贝至栈中，这里也存在一定的开销**。

虽然，有栈协程有上述的缺点，但是它可以在 **任意函数调用层级的位置进行挂起**，并转移调度权。事实上，这也是有栈协程的重要特定之一。

### **无栈协程**

与有栈协程相反，无栈协程不会为各个协程开辟相应的调用栈。无栈协程通常是 **基于状态机或闭包** 来实现。

基于状态机的解决方案一般是通过状态机，记录上次协程挂起时的位置，并基于此决定协程恢复时开始执行的位置。**这个状态必须存储在栈以外的地方**，**从而避免状态与栈一同销毁**。

以 `bar()` 为例，可以通过类似如下的方式实现挂起和恢复。从这种实现方式的角度来看，协程与函数无异，只不过前者会记录上次中断的位置，从而可以实现恢复执行的能力。当然，在实际过程中，恢复后的执行流可能会用到中断前的状态，因此**无栈协程会将保存完整的状态，这些状态会被存储到堆上**。

```cpp
void bar() {
    static int state = 0;
    switch (state) {
        case 0: goto LABEL0;
        case 1: goto LABEL1;
        case 2: goto LABEL2;
    }
    LABEL0:
    std::cout << "1";
    LABEL1:
    std::count << "2";
    LABEL2:
    std::count << "3";
}

```

上述只是一个简单的例子，具体场景中，无栈协程的控制流会依靠对协程本身编译生成的状态机的状态流来实现，变量保存也会通过闭包语法来实现。

**相比于有栈协程，无栈协程不需要修改调用栈，也无需额外的内存来保存调用栈**，因此它的开销会更小。但是，相比于保存运行时上下文这种实现方式，无栈协程的实现还是存在比较多的限制，最大缺点就是，**它无法实现在任意函数调用层级的位置进行挂起**。

---

有栈协程

```c
void* test(void* para){
	co_enable_hook_sys();
	int i = 0;
	poll(0, 0, 0. 1000); // 协程切换执行权，1000ms后返回
	i++;
	poll(0, 0, 0. 1000); // 协程切换执行权，1000ms后返回
	i--;
	return 0;
}

int main(){
	stCoRoutine_t* routine;
	co_create(&routine, NULL, test, 0);// 创建一个协程
	co_resume(routine); 
	co_eventloop( co_get_epoll_ct(),0,0 );
	return 0;
}
```

poll操作对应一个hook机制：**hook后的poll所做的事情就是把当前协程的CPU执行权切换到调用栈的上一层，并在超时或注册的fd就绪时返回**

无栈协程

```cpp
struct test_coroutine {
    int i;
    int __state = 0;
    void MoveNext() {
        switch(__state) {
        case 0:
            return frist();
        case 1:
            return second();
        case 2:
        	return third();
        }
    }
    void frist() {
        i = 0;
        __state = 1;
    }
    void second() {
        i++;
        _state = 2;
    }
    void third() {
    	i--;
    }
};
```

我们可以看到相比与有栈协程中的test函数，这里把整个协程抽象成一个类，**以原本需要执行切换的语句处为界限，把函数划分为几个部分**，**并在某一个部分执行完以后进行状态转移**，在下一次调用此函数的时候就会执行下一部分，这样的话我们就完全没有必要像有栈协程那样显式的执行上下文切换了，我们只需要一个简易的调度器来调度这些函数即可。

从执行时栈的角度来看，其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值，而且**相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别**，这样也可以凸显出无栈协程的高效。

[初识协程 _ 楚权的世界.pdf](Lab%20Multithreading%20--%20%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5barrier%2093561cd54789458a897ea1aad0309f6c/%E5%88%9D%E8%AF%86%E5%8D%8F%E7%A8%8B___%E6%A5%9A%E6%9D%83%E7%9A%84%E4%B8%96%E7%95%8C.pdf)