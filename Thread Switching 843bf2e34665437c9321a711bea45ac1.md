# Thread Switching

板块: 进程 线程

- 线程
    - Thread是一种简化编程抽象，当你想**同时处理多个任务**时
    - 可以想象成一个**单一**的**串行执行**
- 多线程的并行运行主要有两个策略：
    - 多核 每个核一个线程
    - 线程数 > 核心数：Switching
    
- 不同线程系统的不同实现的一个主要区别就是：线程间是否共享内存
- Xv6内核线程系统是共享内存的，Xv6支持**内核线程**概念，对于每个用户进程都有一个内核线程来 执行 来自用户进程的 系统调用 。
    
    所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存
    
- Xv6还有另外的一种线程系统：每一个用户进程都有独立的内存地址空间，且包含了一个线程，这个线程控制了用户进程代码指令的执行。
    
    所以XV6中的**用户线程**之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。
    
    <aside>
    💡 Linux更为复杂：
    允许一个用户进程有多个线程，一个进程内所有线程共享进程的地址空间
    
    </aside>
    
- 线程系统面临的挑战(要解决的问题)
    - 如何实现线程间的切换，XV6为每个CPU核都创建了一个线程调度器
    - 当你想要实际实现从一个线程切换到另一个线程时，你需要保存并恢复线程的状态，所以需要决定**线程的哪些信息是必须保存的，并且在哪保存它们**
    - 如何处理运算密集型线程(compute bound thread) 会花费很多时间运行才结束，不及时让出CPU影响其他线程执行 -- Xv6使用定时器中断
- 两种调度方式 -- 抢占与非抢占
    - pre-emptive scheduling: 抢占式调度
        
        每个CPU上都有一个定时器，每隔一定周期发起的定时器中断打断**用户线程**的执行，将CPU执行权交由**内核的定时器中断处理程序**执行，位于内核的定时器中断处理程序，会自愿的将CPU出让（yield）给**线程调度器**，并告诉线程调度器说，你可以让一些**其他的线程**运行了
        
        (用户进程 --> 定时器中断处理程序 --> 线程调度器 --> 其他用户线程)
        
    - 与之相反的是voluntary scheduling
- 在XV6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权从用户进程给到内核，这里是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让CPU），使用voluntary scheduling。
- 对于RUNNING状态下的线程，它的程序计数器和寄存器位于正在运行它的CPU硬件中。而RUNABLE线程，因为并没有CPU与之关联，所以对于每一个RUNABLE线程，当我们将它从RUNNING转变成RUNABLE时，我们需要将它还在RUNNING时位于CPU的状态拷贝到内存中的某个位置，注意这里不是从内存中的某处进行拷贝，而是从CPU中的寄存器拷贝。我们需要拷贝的信息就是程序计数器（Program Counter）和寄存器。当线程调度器决定要运行一个RUNABLE线程时，这里涉及了很多步骤，但是其中一步是将之前保存的程序计数器和寄存器拷贝回调度器对应的CPU中。
- trapframe: 如果程序执行了一个系统调用或者因为响应中断切入内核时需要保存到的"用户空间状态" 内含PC指针(program counter)，同时属于这个用户程序的**内核线程**被**激活**(CPU被切换到内核栈上运行,实际上会走到trampoline和usertrap代码中。之后内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后，如果需要返回到用户空间，trapframe中保存的用户进程状态会被恢复。)
    
    除了系统调用，用户进程也有可能是因为CPU需要响应类似于定时器中断走到了内核空间。上一节提到的pre-emptive scheduling，会通过定时器中断将CPU运行切换到另一个用户进程。在定时器中断程序中，如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中*第一个进程* 的内核线程会被切换到*第二个进程* 的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回也是通过恢复trapframe中保存的用户进程状态完成。
    

- 当XV6从CC程序的内核线程切换到ls程序的内核线程时：
    
    1.XV6会首先会将CC程序的内核线程的内核寄存器保存在一个context对象中。
    2.类似的，因为要切换到LS程序的内核线程，那么LS程序现在的状态必然是RUNABLE，表明LS程序之前运行了一半。这同时也意味着LS程序的用户空间状态已经保存在了对应的trapframe中，更重要的是，LS程序的内核线程对应的内核寄存器也已经保存在对应的context对象中。所以接下来，XV6会恢复LS程序的内核线程的context对象，也就是恢复内核线程的寄存器。
    3.之后LS会继续在它的内核线程栈上，完成它的中断处理程序（注，假设之前LS程序也是通过定时器中断触发的pre-emptive scheduling进入的内核）。
    4.然后通过恢复LS程序的trapframe中的用户进程状态，返回到用户空间的LS程序中。
    5.最后恢复执行LS。
    
    这里核心点在于，在XV6中，任何时候都需要经历：
    
    1. 从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。
    2. 再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。
    3. 之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。
    4. 最后返回到第二个用户进程继续执行。
    
    这么曲折的一个线路。
    
- 内核会在两个场景下出让CPU。当定时器中断触发了，内核总是会让当前进程出让CPU，因为我们需要在定时器中断间隔的时间点上交织执行所有想要运行的进程。另一种场景就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。

- **Xv6中的swtch只能在 一个用户进程的内核线程 和 专属这个CPU的内核调度器线程**(类似于用户进程切换到内核进程时trampoline的作用)
    
    每个CPU各自都有一个属于各自的调度器线程，有属于每个CPU的寄存器，在struct cpu中的context保存，同时每个CPU的调度线程的stack、线程设置、寄存器context设置都在上电时machine code下执行初始化设置 (boot time) (entry.S?)
    

- 三类线程

- 学生提问：为什么不能将context对象保存在进程对应的trapframe中？
Robert教授：context可以保存在trapframe中，因为每一个进程都只有一个内核线程对应的一组寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰的目的，trapframe还是**只**包含**进入和离开内核时**的数据。而**context**结构体中包含的是在**内核线程和调度器线程之间切换时**，需要保存和恢复的数据。

- swtch.S
    
    ```c
    # Context switch
    #
    #   void swtch(struct context *old, struct context *new);
    # 
    # Save current registers in old. Load from new.	
    
    # 为什么RISC-V中有32个寄存器，但是swtch函数中只保存并恢复了14个寄存器？
    # 因为swtch是按照一个普通函数来调用的，对于有些寄存器，swtch函数的调用者默认swtch函数会做修改，
    # 所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以swtch函数里只需要保存这些会被更改的Callee Saved Register就行。
    # 而我们在swtch函数中只需要处理C编译器不会保存，但是对于swtch函数又有用且会占用的一些寄存器
    
    # a0是调用swtch函数的第一个参数
    # p->context(用户进程的内核线程使用的寄存器) store当前(尚未切换前)内核线程使用的寄存器内容到内核线程context数据结构做保存
    
    # a1是调用swtch函数的第二个参数
    # mycpu()->context是之前所属CPU的调度器线程使用的寄存器内容暂存的数据结构 这里将这些数据从内存中恢复load到寄存器中准备给调度器使用
    # 这里关键是设置ra寄存器为上次离开调度器scheduler函数的地方 proc.c:484[swtch(&c->context, &p->context);]
    .globl swtch
    swtch:
            sd ra, 0(a0)
            sd sp, 8(a0)
            sd s0, 16(a0)
            sd s1, 24(a0)
            sd s2, 32(a0)
            sd s3, 40(a0)
            sd s4, 48(a0)
            sd s5, 56(a0)
            sd s6, 64(a0)
            sd s7, 72(a0)
            sd s8, 80(a0)
            sd s9, 88(a0)
            sd s10, 96(a0)
            sd s11, 104(a0)
    
            ld ra, 0(a1)
            ld sp, 8(a1)
            ld s0, 16(a1)
            ld s1, 24(a1)
            ld s2, 32(a1)
            ld s3, 40(a1)
            ld s4, 48(a1)
            ld s5, 56(a1)
            ld s6, 64(a1)
            ld s7, 72(a1)
            ld s8, 80(a1)
            ld s9, 88(a1)
            ld s10, 96(a1)
            ld s11, 104(a1)
            
            ret
    ```