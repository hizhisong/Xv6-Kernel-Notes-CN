# 用户虚拟地址空间、内核虚拟地址空间、物理地址的建立与映射

Status: Completed
板块: 内存管理, 启动

# 一切皆为虚拟地址

RISC-V指令(包括**用户**和**内核**)操作的是**虚拟地址**

对于 用户进程 来说，其操作的是进程虚拟地址空间

对于 内核 这个程序来说，其操作的是内核虚拟地址空间

![右上角点击Original查看原图](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled.png)

右上角点击Original查看原图

我们看到这张图：

1. 总共有三个地址空间布局：(详解看图)
    1. **最中间**的地址空间是**内核虚拟地址空间**布局：它也拥有一个`0 ~ MAXVA`的虚拟地址空间
        1. 顶部的为Trampoline 和 内核栈(in each process pbc，当进程在内核态执行代码时使用该内核栈)
        2. 内核作为一个程序/可执行文件，被BootLoader加载进物理地址0x80000000处，稍后直接映射到内核虚拟地址空间【KERNELBASE ～ end是内核数据、代码段】
        3. 在内核执行文件结束后的【end~PHYSTOP地址为用户进程、内核页(by kalloc)】申请的区域，由于直接映射，这部分空间内核虚拟地址空间与物理内存地址一致
        4. 设备被安排到KERNELBASE以下的地址映射
    2. 对于每个**用户进程的虚拟地址空间**布局是**最左侧**的：
        
        从0开始装载程序，text、data、stack、heap、trapframe、trampoline，其中每个用户进程的trampoline和内核地址空间的trampoline都是在同一个虚拟地址空间范围上
        
    3. 对于这张表**最右侧**的Physical Address是直接的**物理地址**：
        
        回到最初那张图的右侧：物理地址的分布。可以看到最下面是未被使用的地址，这与主板文档内容是一致的（地址为0）。地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。
        
        物理地址`从0x80000000开始到PHYSTOP`为实体物理内存硬件，这个范围应该是开机检测而定的大小，但我们这里简便期间规定了
        
        PHYSTOP的值，规定了硬件内存空间大小。物理地址空间其大部分直接映射于内核虚拟地址空间。
        
        Xv6实验中，使用QEMU将设备接口作为memory-mapped(内存映射)控制寄存器 暴露给软件，这些寄存器位于物理地址空间的0x80000000以下。内核可以通过读取/写入这些特殊的物理地址与设备进行交互；这种读取和写入与设备硬件而不是与RAM进行通信。
        
2. 映射：
    1. 内核虚拟地址空间我们可以看到在内核启动时建立与物理内存的联系，大多数空间都是内核虚拟地址直接映射硬件物理地址，但除了内核物理地址空间中的两部分：
        1. Trampoline
        2. 内核栈 Kernel Stacks
    2. 将一个用户进程加载到物理内存中来，建立用户虚拟地址空间对物理内存的使用，我们需要先向内核发出内存的申请内存页，内核在内核虚拟地址空间的`kernel结束后~PHYSTOP`范围内申请Pages将其映射给用户进程的虚拟地址空间，由于内核虚拟地址空间在内核初始化时已经映射了物理内存，因此这里相当于用户虚拟地址空间通过内核虚拟地址空间间接使用了物理地址空间

# 建立 内核虚拟地址空间 映射、开启分页

![Untitled](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled%201.png)

![Untitled](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled%202.png)

建立空闲页链表这样的数据结构供申请使用

![Untitled](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled%203.png)

![Untitled](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled%204.png)

在上述[这张图](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81.md)中我们看到中间的内核虚拟地址空间**直接映射**到物理地址空间地址的情况就是在这里实现操作的，这里建立了内核虚拟地址空间(页表) `kernel_pagetable`

![Untitled](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/Untitled%205.png)

接下来开启分页机制将内核跟页表物理地址填入satp寄存器(根页表寄存器)并刷新TLB，

至此，我们就能让用户进程使用内核页表了？？？// TODO

# 用户虚拟地址空间

当进入到用户模式时，我们将内核页表的根地址放入`p->trapframe->kernel_pagetable`中，当再次进入内核态，我们再将satp寄存器设置为`p->trapframe->kernel_pagetable`的值。(trap.c trampoline.S)

![出内核进用户空间](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/%E5%9B%BE%E7%89%876.png)

出内核进用户空间

![进内核](%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%98%A0%E5%B0%84%20c8a04106e5d64643919a6b4dbf1fba81/%E5%9B%BE%E7%89%877.png)

进内核

[物理内存如何组织管理以供使用](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E4%BB%A5%E4%BE%9B%E4%BD%BF%E7%94%A8%20c67d1d2715144ac9a47c0665b92b4f81.md) 

<aside>
💡 下一回:

[分页机制](%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%200c97caa5ff76434b89f8e4d1c363d987.md)

</aside>