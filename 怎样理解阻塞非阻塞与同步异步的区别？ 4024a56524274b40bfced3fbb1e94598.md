# 怎样理解阻塞非阻塞与同步异步的区别？

板块: IO与文件系统

[怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473/answer/241673170#)

[](https://briansun.feishu.cn/mindnotes/bmncnT47XcIs8I4b19l3r6ZJ5fb)

Ans：

1. 同步和阻塞是基本上同义词，异步和非阻塞基本上是同义词
2. 讨论这个问题，分为**接收方**与**发送方**两方（由于进程通信就是围绕着send和recevice走）
    
    <aside>
    💡 * 阻塞式发送（blocking send）
    发送方进程会被一直阻塞， 直到消息被接受方进程收到。
    * 非阻塞式发送（nonblocking send）
    发送方进程调用 send() 后， 立即就可以其他操作。
    
    * 阻塞式接收（blocking receive） 
    接收方调用 receive() 后一直阻塞， 直到消息到达可用。
    * 非阻塞式接受（nonblocking receive） 
    接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。
    
    1. 四种可以两两组合构成了进程间通信
    2. 发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。
    3. 其实**阻塞和非阻塞**描述的是进程的一个操作是否会使得进程转变为“**等待**”(**放弃CPU**)的状态
    
    </aside>
    

# IO模型

## 阻塞IO系统调用

读/写syscall请求发出后，进程暂停执行被挂起，在阻塞期间进程**不会**占用CPU，调度其他进程的运行， 等到 它所请求的 I/O 操作完成了以后， 再将其状态更改回 ready

例如：用户向OS发出磁盘读

因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）

## 非阻塞IO系统调用

一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。

系统调用返回后该进程不挂起，将做其他的事

等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。

## 异步IO调用

而**异步I/O系统调用** read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点

系统调用返回后该进程不挂起，将做其他的事

等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。

<aside>
💡 **非阻塞I/O 系统调用( nonblocking system call )**和 **异步I/O系统调用** 都是**非阻塞式的行为**（non-blocking behavior）。 他们的差异仅仅是返回结果的方式和内容不同

</aside>

# 利用****非阻塞 I/O 帮助服务器提高吞吐量****